| <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Generally, we should aim for small aggregates.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| For aggregates, we are looking for transactional consistency, not eventual consistency; we want any changes to our aggregate to be immediate and atomic. Therefore, we can think of an aggregate as a transactional consistency boundary.                                                                                                                                                                                                                                                                                            |
| An invariant is simply a rule in our domain that must always be true. For example, we may say that in our system, for an order to be created, we must have the item in stock. This is a business invariant.                                                                                                                                                                                                                                                                                                                          |
| Before trying to cluster our domain models into aggregates, we need to find our bounded context’s invariants.                                                                                                                                                                                                                                                                                                                                                                                                                        |
| aggregates are confused with data structures used for collections of data, such as arrays, maps, and slices. These are not the same thing. While an aggregate may use these collections, an aggregate is a DDD concept and, therefore, will usually contain multiple collections, fields, functions, and methods. Instead, the job of an aggregate pattern is to act as a transaction boundary for the domain objects within. Loading, saving, editing, and deleting should happen to all objects within the aggregate or not at all |
| An order: Typically, an order consists of individual items, but it is helpful to treat them as a single thing (an order) for some purposes within our system                                                                                                                                                                                                                                                                                                                                                                         |
| aggregate pattern refers to a group of domain objects that can be treated as one for some behaviors                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Aggregates are probably one of the hardest patterns of domain-driven design and are, therefore, often implemented incorrectly                                                                                                                                                                                                                                                                                                                                                                                                        |
| Try and make everything a value object to start with until it does not fit your use case. At that point, it can be upgraded to an entity.                                                                                                                                                                                                                                                                                                                                                                                            |
| If you care only about the values of an object, then it should preferably be a value object. Some other questions to ask yourself to ensure a value object is the right choice for you are:<br><br>  <br><br>    Is it possible for me to treat this object as immutable?<br><br>    Does it measure, quantify, or describe a domain concept?<br><br>    Can it be compared to other objects of the same type by its values?                                                                                                         |
| We should aim to use value objects as much as possible when modeling our domain. This is because they are the safest constructs we can use when implemented correctly                                                                                                                                                                                                                                                                                                                                                                |
| Value objects are, in some ways, the opposite of entities. With value objects, we want to assert that two objects are the same given their values.                                                                                                                                                                                                                                                                                                                                                                                   |
| We also want to keep the coupling between our entity and ORM to a minimum. Therefore, I recommend you use an adaptor layer to decouple your ORM and DDD entity layer.                                                                                                                                                                                                                                                                                                                                                                |
| If you want to use an ORM, ensure it does not control how you write your entities in your DDD context; otherwise, you may end up with an anemic model.                                                                                                                                                                                                                                                                                                                                                                               |
| Anemic models have little or no domain behavior as part of their design. This means that you are not getting the full benefit of DDD. In my experience, entities are where anemia shows up most often. It is quite easy to diagnose anemic models and course-correct them if they’re identified early enough. If your model has mostly public getter and setter functions, no business logic, or depends on various clients to implement the business logic, you probably have an anemic model.                                      |
| Due to the focus of entities being on their identity, it is very easy to fall into the trap of letting the database design dictate what your domain model will look like. This can lead to what is known as an anemic domain model.                                                                                                                                                                                                                                                                                                  |
| One interesting case is a user’s email address. At a glance, email addresses might seem like good entity identifiers as we will require them to be unique. However, in most systems, users can change the email address they will receive notifications on. Therefore, email addresses would be much better suited to be an attribute of the entity.                                                                                                                                                                                 |
| Entity IDs do not necessarily have to be generated by the system. They may form part of the entity’s attributes.                                                                                                                                                                                                                                                                                                                                                                                                                     |
| entities are defined by their identity. Their attributes do not define them, and it is expected that although their attributes may change over time, their identity will not.                                                                                                                                                                                                                                                                                                                                                        |
| We will finish by looking at aggregates, which are useful when we need to cluster domain objects together and treat them as a single item.                                                                                                                                                                                                                                                                                                                                                                                           |
| We will start by looking at entities and value objects. This is where we will write most of the business logic                                                                                                                                                                                                                                                                                                                                                                                                                       |
| This would go against the principles of DDD and mean we are strongly coupling the domain model to something outside of our control.<br><br>We can write an anti-corruption layer                                                                                                                                                                                                                                                                                                                                                     |
| Sometimes called an adapter layer, an anti-corruption layer can be used to translate models from different systems. It is a complementary pattern that works well with the Open Host Service.                                                                                                                                                                                                                                                                                                                                        |
| Either! You will have great results with either approach. Due to gRPC’s speed and extra features, it is becoming more popular. However, OpenAPI can be easier to retrofit to already existing APIs and is easier to understand                                                                                                                                                                                                                                                                                                       |
| To call a method on a remote server, firstly, we must define our message protobuf. Protobufs are typically defined in a .proto file, and they are language-agnostic                                                                                                                                                                                                                                                                                                                                                                  |
| The downside to OpenAPI is that there are more performant alternatives out there. Furthermore, OpenAPI does not give any protection for breaking changes natively. For example, if you removed a field from your documentation, but another team depended on it, you would likely break their workflow.                                                                                                                                                                                                                              |
| OpenAPI is a great option for your published language if you and your team are already familiar with REST APIs. OpenAPI is documentation-first, which means your external-facing documentation is always kept up to date, which is a huge advantage. The code generation means you can support many different use cases with no extra effort.                                                                                                                                                                                        |
| Two popular ways to present published language are via OpenAPI or gRPC                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ubiquitous language is our team’s internal formally defined language; a published language is the opposite. If our team is going to expose some of our systems to other teams via an Open Host Service, we need to ensure the definition of what we expose to other teams in different bounded contexts is clear.                                                                                                                                                                                                                    |
| An Open Host Service is a means of giving other systems (or sub-systems) access to ours                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Since several bounded contexts often must communicate as shown in Figure 2.3, we often apply patterns to ensure our models can maintain integrity. The three main patterns are as follows:<br><br>  <br><br>Open Host Service<br><br>Published language<br><br>Anti-corruption layer                                                                                                                                                                                                                                                 |
| The reason for this is that ubiquitous language works best when it is rigorous. If you try to make a specific word (especially, loaded terms such as customer or user) apply to all different areas of your business, the term will lose that rigor, and confusion will reign.                                                                                                                                                                                                                                                       |
| It can be tempting to try to apply a ubiquitous language across multiple projects, teams, and even across an entire company. However, if you do this, you are setting yourself up for failure. Evans advises that ubiquitous language should only apply to a single bounded context                                                                                                                                                                                                                                                  |
| ubiquitous language should be used in the source code itself                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Although domain experts are fundamental to definitions, engineers must challenge them and think about edge cases to ensure the definitions are robust                                                                                                                                                                                                                                                                                                                                                                                |
| Ubiquitous language is the overlap of the language that domain experts and technical experts use.                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| Tactical design is where we begin to get into the specifics of how our system will look. In the tactical design phase, we begin talking about entities, aggregates, and value objects                                                                                                                                                                                                                                                                                                                                                |
| Ubiquitous language is the term we use to describe the process of building a common language we can use when talking about our domain. This language should be spoken by everyone in the team—developers and business folk alike. It unites the team by ensuring there is no ambiguity in communication.                                                                                                                                                                                                                             |
| Strategic design is a phase of the DDD process in which we map out the business domain and define bounded contexts.                                                                                                                                                                                                                                                                                                                                                                                                                  |
| Evans introduced three main concepts (sometimes called pillars) of DDD. These are ubiquitous language, strategic design, and tactical design                                                                                                                                                                                                                                                                                                                                                                                         |