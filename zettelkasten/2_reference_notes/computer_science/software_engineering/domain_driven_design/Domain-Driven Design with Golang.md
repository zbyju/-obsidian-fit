# Book information
- Author: #matthew-boyle
- Tags: #book
---
# Notes
There are 3 main pillars:
1. Ubiquitous language
	- The process of building a common language (between engineers and business)
2. Strategic design
	- The process of mapping out the business domain and bounded contexts
3. Tactical design
	- The process of defining the specifics of the design (entities, aggregates, value objects).

## Ubiquitous language
= overlap of the language engineers and domain experts use

Important that engineers challenge domain experts (especially in the edge cases) such that the definitions are sounded and consistent.

The established language should be used inside the code itself.

Ubiquitous language should always be applied only to one bounded context.
- One word might mean something else in different contexts and that's okay.
- The language should be rigorous, it shouldn't lose its meaning.
	- Customer might mean different things in different contexts, don't try to merge the meanings because we are losing rigorousness.

To capture such language it is needed to talk to domain experts a lot, try to attend their meetings and take notes, especially list all the words that you don't know.
### Bounded context
We should avoid applying the same language across the whole project and we should create contexts in which it makes sense to have a ubiquitous language.

These bounded contexts often need to interact which is done through:
1. Open Host Service
2. Published language
3. Anti-corruption layer
#### Open Host Service
This is the way of giving other systems access to ours. This can be:
- RPC (simple function call)
- REST API
- GraphQL
- gRPC
#### Published language
Ubiquitous language is our internal language for our system/subsytem/module, published language should be the opposite. 

This means making sure the information we publish should be usable to other teams/systems that are going to be consuming it. But also that the published language is understandable. We can ensure that using:
- OpenAPI
	- can help us creating a schema and a description of what it is we are publishing
	- documentation-first => documentation is always 
	- not the most performant (in Go)
	- no protection against breaking changes
		- if you change some fields and other team depends on it, it will break their workflow
- gRPC
#### Anti-corruption layer
= adapter layer

It can be used to translate models from different systems.

*Example: let's say we have 2 models in 2 systems that are basically the same minus the naming of the fields. Solution 1: rename the fields to match => this goes against DDD. Solution 2: anti-corruption layer.*

Anti-corruption layer is a middleware between two systems that is translating models from one system to the model of another (and vice versa).

It is also a good solution for interacting with systems that don't use DDD at all.
## Strategic design
## Tactical design
### Entity
Entities are defined by their identity (ID) and not by their attributes. Even more so it is expected that their attributes will change over time while they are still the same "object".

Identity can be generated by the system or naturally be part of the entity's attributes.

*Example: Person's age, name, address can change but they are still the same person; they also have some identifier (e.g. social security number, or system's UUID)*

*Example 2: Email address can be a good ID or bad ID - if we have a user that can change their email address then it is a bad ID, but if we want to treat the same person as different users we might use an immutable email address as their ID*
#### Generating IDs
1. `int` counter
	- Scaling problems
2. uuid
#### Anemic models
Anemic models have very little to no logic or domain behavior. Most often happens for entities (or aggregates).

They can be identified by having (many) getters or setters.

External dependencies (ORMs, databases, APIs, ...) should never influence how are models look like.
Don't let the database dictate how the model should look like (might lead to anemic models). Same with ORMs.
### Value Object
Value objects are defined by their attributes. If some attribute changes it becomes a different "object".

Value objects should be immutable.

If we want to modify some value, the method for that should return a new instance of that object.
### Value Object vs Entity
How to decide between one or the other?

We should start with making everything a value object. They are the simplest and we don't have to worry about consumers modifying them in a wrong way. They are easier to implement correctly.

Some questions:
1. Is it possible to treat this object as immutable?
2. Does it measure/quantify/describe a domain concept?
3. Can it be compared to other object (of the same type) by its values?
If answer is 3x yes, then value object is probably correct.

If we make everything a value object and then slowly convert some object to entities, that is a pretty good strategy.
### Aggregate
Aggregate refers to a group of domain objects that can be treated as one for some behaviors. **It acts as a transaction boundary for the domain objects within.**

Operations should be done "atomically/transactionally" to all the domain objects or to none.

*Examples:*
- *Order - many operations are done for the entire order as a whole*
- *Team - we can apply operations to a team of employees*

We should try keeping them small:
- better scalability
- better performance
- better chance of transaction succeeding

Outside of aggregates we should strive for eventual consistency.
#### Discovering aggregates
We need to find bounded context's invariants (rules that must always be true).

When we are dealing with aggregates we are declaring that we are looking for a **transactional consistency** instead of eventual consistency.
### Factory
Factories **standardize** (and ensure invariants are enforced) the way we create domain objects while **hiding additional logic** and only exposing the minimal interface for creating the object.

#### Entity factory
They should provide the minimal interface for creating the entity, additional properties can be passed via methods on the entity to change its state.

This is a good place for generating IDs for the entity. Although passing the ID in is a also viable.
### Repository
It is a layer for interacting with data sources (e.g. database, S3, files, ...). They are an interface with an implementation, which allows us to replace these implementations to change the underlying data source (switching databases).

*Common mistake: creating one struct/class per database table. Instead create one struct per aggregate.*
#### Command and Query Responsibility Segregation (CQRS)
Approach where commands access the repository layer but queries go directly fetch the data from the data source.

This works because queries don't (shouldn't) modify the data and therefore break any invariants/logic.
### Services
Services further help structure our code.
#### Domain services
They are for stateless operations that we can't model well on any domain object => they go into a domain service.

How to tell to user domain service:
1. The code is performing a significant piece of business logic
2. Transforming one domain object into another
3. Using multiple domain objects

We still need to be using ubiquitous language.

When other consumers are using this service we are making sure that business invariants are enforced.

Domain services interact only with domain objects (not going outside the domain layer).
#### Application services
They are used for composing other services and repositories. They are responsible for managing transactional guarantee and they don't contain domain logic.

They should be super thin, only calling other services/layers or address security concerns.

---

# Summary

---

# Final thoughts
## Content
## Style
## Value
## Comparisons and links

---